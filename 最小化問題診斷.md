# 最小化問題診斷

## 問題分析

### 當前行為
用戶反饋：**程式仍然沒有最小化**

### 可能原因

#### 原因 1: "最小化自動啟動排程" 沒有勾選
`OnResize` 方法中的條件：
```csharp
if (WindowState == FormWindowState.Minimized && chkMinToTray.Checked)
```

如果 `chkMinToTray.Checked` 是 `false`，整個邏輯區塊不會執行。

**測試步驟**：
1. 確認是否勾選了「最小化自動啟動排程」
2. 如果沒勾選，視窗只會最小化到工作列（預設 Windows 行為）

#### 原因 2: OnResize 事件沒有觸發
可能的原因：
- 事件沒有正確訂閱
- 被其他代碼覆蓋

#### 原因 3: Hide() 執行時機問題
`Hide()` 在 `OnResize` 中被調用，但可能：
- 視窗已經最小化，`Hide()` 不影響工作列圖示
- 需要先檢查 `ShowInTaskbar` 屬性

## 正確的解決方案

### 方案 A: 無論是否勾選，都隱藏到托盤

如果用戶期望「點擊最小化就應該隱藏到托盤」，應該改為：

```csharp
protected override void OnResize(EventArgs e)
{
    base.OnResize(e);
    if (WindowState == FormWindowState.Minimized)
    {
        // 隱藏視窗到托盤
        Hide();
        
        // 只有勾選「最小化自動啟動排程」才自動啟動排程器
        if (chkMinToTray.Checked && !_scheduler.IsRunning)
        {
            _scheduler.Start();
            btnToggleScheduler.Text = "停止排程";
            lstLog.Items.Insert(0, $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] 最小化到托盤 - 自動啟動排程器");
            _trayIcon?.ShowBalloonTip(2000, "自動啟動排程器", 
                "視窗已最小化到系統托盤\n排程器已自動啟動", ToolTipIcon.Info);
        }
        else
        {
            lstLog.Items.Insert(0, $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] 已最小化到托盤");
            _trayIcon?.ShowBalloonTip(2000, "已最小化", 
                "視窗已最小化到系統托盤", ToolTipIcon.Info);
        }
        
        UpdateTrayTextAndIcon();
    }
}
```

### 方案 B: 保持當前邏輯，但加入調試

如果「最小化自動啟動排程」的意義是「最小化時才隱藏到托盤」，需要：

```csharp
protected override void OnResize(EventArgs e)
{
    base.OnResize(e);
    
    // 調試：記錄所有最小化事件
    if (WindowState == FormWindowState.Minimized)
    {
        lstLog.Items.Insert(0, $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] 偵測到最小化，chkMinToTray={chkMinToTray.Checked}");
    }
    
    if (WindowState == FormWindowState.Minimized && chkMinToTray.Checked)
    {
        // 隱藏視窗並移到系統托盤
        Hide();
        
        // 檢查排程器狀態並自動啟動
        if (!_scheduler.IsRunning)
        {
            _scheduler.Start();
            btnToggleScheduler.Text = "停止排程";
            lstLog.Items.Insert(0, $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] 最小化到托盤 - 自動啟動排程器");
            _trayIcon?.ShowBalloonTip(2000, "自動啟動排程器", 
                "視窗已最小化到系統托盤\n排程器已自動啟動", ToolTipIcon.Info);
        }
        else
        {
            lstLog.Items.Insert(0, $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] 最小化到托盤 - 排程器已在運行中");
            _trayIcon?.ShowBalloonTip(2000, "已最小化", 
                "視窗已最小化到系統托盤\n排程器執行中", ToolTipIcon.Info);
        }
        
        UpdateTrayTextAndIcon();
    }
}
```

### 方案 C: 使用 ShowInTaskbar 屬性

更完善的方式：

```csharp
protected override void OnResize(EventArgs e)
{
    base.OnResize(e);
    if (WindowState == FormWindowState.Minimized && chkMinToTray.Checked)
    {
        // 從工作列移除
        ShowInTaskbar = false;
        // 隱藏視窗
        Hide();
        
        // 檢查排程器狀態並自動啟動
        if (!_scheduler.IsRunning)
        {
            _scheduler.Start();
            btnToggleScheduler.Text = "停止排程";
            lstLog.Items.Insert(0, $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] 最小化到托盤 - 自動啟動排程器");
            _trayIcon?.ShowBalloonTip(2000, "自動啟動排程器", 
                "視窗已最小化到系統托盤\n排程器已自動啟動", ToolTipIcon.Info);
        }
        else
        {
            lstLog.Items.Insert(0, $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] 最小化到托盤 - 排程器已在運行中");
            _trayIcon?.ShowBalloonTip(2000, "已最小化", 
                "視窗已最小化到系統托盤\n排程器執行中", ToolTipIcon.Info);
        }
        
        UpdateTrayTextAndIcon();
    }
}

private void RestoreFromTray()
{
    Show();
    ShowInTaskbar = true; // 恢復到工作列
    WindowState = FormWindowState.Normal;
    Activate();
}
```

## 診斷步驟

1. **檢查「最小化自動啟動排程」是否勾選**
   - 如果沒勾選，視窗只會最小化到工作列（這是正常的 Windows 行為）

2. **檢查執行紀錄**
   - 看是否有「偵測到最小化」的記錄
   - 如果沒有，表示 `OnResize` 沒有被觸發

3. **測試托盤功能**
   - 雙擊托盤圖示是否能恢復視窗
   - 右鍵托盤選單是否正常

## 建議修正

根據用戶期望，我認為應該採用 **方案 C**，因為：

1. 使用 `ShowInTaskbar = false` 可以確保工作列圖示消失
2. 使用 `Hide()` 隱藏視窗
3. 恢復時設定 `ShowInTaskbar = true` 確保圖示重新出現

這樣可以確保視窗真正「最小化到托盤」而不是「最小化到工作列」。
